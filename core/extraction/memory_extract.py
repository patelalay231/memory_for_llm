from core.providers.base import LLMProvider
from core.prompts import get_memory_extraction_prompt
from core.models.Memory import Memory
from logger import Logger
import json


class MemoryExtract:
    """
    Memory extraction class with validation and retry logic.
    """
    
    def __init__(self, provider: LLMProvider, max_retries: int = 3):
        """
        Initialize the memory extraction class.
        
        Args:
            provider: LLM provider instance
            max_retries: Maximum number of retry attempts (default: 3)
        """
        self.provider = provider
        self.max_retries = max_retries

    def extract_memory(self, recent_messages: list[dict], user_message: str, assistant_message: str) -> list[Memory]:
        """
        Extract and validate memories with retry logic.
        
        Args:
            recent_messages: List of recent conversation turns
            user_message: Current user message
            assistant_message: Current assistant response
            
        Returns:
            List of validated Memory objects
            
        Raises:
            Exception: If extraction fails after max_retries attempts
        """
        Logger.debug("Starting memory extraction...", "[MemoryExtract]")
        
        for attempt in range(self.max_retries):
            try:
                if attempt > 0:
                    Logger.debug(f"Retry attempt {attempt + 1}/{self.max_retries}...", "[MemoryExtract]")
                
                # Get LLM response (no conversation_summary)
                Logger.debug("Sending prompt to LLM...", "[MemoryExtract]")
                prompt = get_memory_extraction_prompt(
                    recent_messages=recent_messages,
                    user_message=user_message,
                    assistant_message=assistant_message
                )
                # Call provider with prompt as message (system_instruction is optional)
                response = self.provider.send_message(prompt, system_instruction=None)
                Logger.debug("Received response from LLM, validating...", "[MemoryExtract]")
                
                # Validate and parse
                memories = self._parse_and_validate(response)
                Logger.debug(f"Successfully extracted {len(memories)} memory/memories", "[MemoryExtract]")
                return memories  # Success!
                
            except (ValueError, json.JSONDecodeError) as e:
                Logger.error(f"Validation failed: {e}", "[MemoryExtract]")
                if attempt == self.max_retries - 1:
                    Logger.error(f"Failed after {self.max_retries} attempts", "[MemoryExtract]")
                    raise Exception(f"Failed after {self.max_retries} attempts: {e}")
                # Retry...
                continue
        
        Logger.debug("No memories extracted", "[MemoryExtract]")
        return []  # No memories extracted
    
    def _parse_and_validate(self, raw_output: str) -> list[Memory]:
        """
        Parse JSON and validate against Memory model.
        
        Args:
            raw_output: Raw string output from LLM
            
        Returns:
            List of validated Memory objects
            
        Raises:
            ValueError: If JSON structure is invalid
            json.JSONDecodeError: If JSON parsing fails
        """
        # Strip markdown code blocks
        cleaned = self._clean_json_output(raw_output)
        
        # Parse JSON
        try:
            data = json.loads(cleaned)
        except json.JSONDecodeError as e:
            raise json.JSONDecodeError(f"Invalid JSON format: {e}", e.doc, e.pos)
        
        # Validate structure
        if "memories" not in data:
            raise ValueError("Missing 'memories' field in JSON response")
        
        if not isinstance(data["memories"], list):
            raise ValueError("'memories' field must be a list")
        
        if len(data["memories"]) == 0:
            Logger.debug("No memories found in response (empty list)", "[MemoryExtract]")
            return []
        
        # Convert to Memory objects (Pydantic handles validation)
        # Note: memory_id and timestamp will be auto-generated by Pydantic
        memories = []
        for idx, m in enumerate(data["memories"]):
            try:
                # Only pass fields that exist in LLM output (source, content, type)
                memory = Memory(
                    source=m.get("source"),
                    content=m.get("content"),
                    type=m.get("type"),
                )
                memories.append(memory)
                Logger.debug(f"Validated memory {idx + 1}: {memory.type} - {memory.content[:50]}...", "[MemoryExtract]")
            except Exception as e:
                Logger.error(f"Failed to validate memory {idx + 1}: {e}", "[MemoryExtract]")
                raise ValueError(f"Invalid memory structure at index {idx}: {e}")
        
        return memories
    
    def _clean_json_output(self, raw: str) -> str:
        """
        Remove markdown code blocks if present.
        
        Args:
            raw: Raw string output
            
        Returns:
            Cleaned string without markdown code blocks
        """
        # Remove ```json ... ``` or ``` ... ```
        if raw.strip().startswith("```"):
            lines = raw.strip().split("\n")
            if lines[0].startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            return "\n".join(lines)
        return raw
